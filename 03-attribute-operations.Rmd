# Opérations sur les attributs des élements {#attr}

## Prérequis {-}

- Ce chapitre nécessite l'installation et le chargement des paquets suivant :  

```{r 03-attribute-operations-1, message=FALSE}
library(sf)      # paquet pour les données vectorielles présenté dans le Chapitre 2
library(terra)   # paquet pour les données raster présenté dans le Chapitre 2
library(dplyr)   # paquet du tidyverse pour la manipulation de tableau de donnée
```

- Il s'appuie également sur **spData**, qui charge des jeux de données utilisés dans les exemples de ce chapitre :

```{r 03-attribute-operations-2, results='hide'}
library(spData)  # paquet de données spatiales présenté dans le Chapitre 2
```

## Introduction

Les données attributaires sont des informations non spatiales associées à des données géographiques (géométrie).
Un arrêt de bus en est un exemple simple : sa position est généralement représentée par des coordonnées de latitude et de longitude (données géométriques), en plus de son nom.
L'arrêt [Elephant & Castle / New Kent Road](https://www.openstreetmap.org/relation/6610626) à Londres, par exemple, a pour coordonnées -0,098 degrés de longitude et 51,495 degrés de latitude, ce qui peut être représenté par `POINT (-0,098 51,495)` dans la représentation `sfc` décrite au chapitre \@ref(spatial-class).
Les attributs tels que le nom *attribut*\index{attribut} de élément POINT (pour utiliser la terminologie de *Simple Features*) sont le sujet de ce chapitre.

```{r, eval=FALSE, echo=FALSE}
# Objectif: trouver un arrêt de bus dans le centre de Londre
library(osmdata)
london_coords = c(-0.1, 51.5)
london_bb = c(-0.11, 51.49, -0.09, 51.51)
bb = tmaptools::bb(london_bb)
osm_data = opq(bbox = london_bb) %>% 
  add_osm_feature(key = "highway", value = "bus_stop") %>% 
  osmdata_sf()
osm_data_points = osm_data$osm_points
osm_data_points[4, ]
point_vector = round(sf::st_coordinates(osm_data_points[4, ]), 3)
point_df = data.frame(name = "London bus stop", point_vector)
point_sf = sf::st_as_sf(point_df, coords = c("X", "Y"))
```

Un autre exemple est la valeur d'élévation (attribut) pour un pixel spécifique dans les données raster.
Contrairement au modèle de données vectorielles, le modèle de données raster stocke indirectement les coordonnées de la cellule de grille, ce qui signifie que la distinction entre attribut et information spatiale est moins claire.
Pour illustrer ce point, pensez à un pixel dans la 3^e^ ligne et la 4^e^ colonne d'une matrice matricielle.
Son emplacement spatial est défini par son indice dans la matrice : déplacez-vous depuis l'origine de quatre cellules dans la direction x (généralement vers l'est et la droite sur les cartes) et de trois cellules dans la direction y (généralement vers le sud et le bas).
La *résolution* de la trame définit la distance pour chaque étape x et y qui est spécifiée dans  l'*en-tête* du fichier.
L'en-tête est un composant essentiel des ensembles de données raster qui spécifie comment les pixels se rapportent aux coordonnées géographiques (voir également le chapitre \@ref(spatial-operations)).

Vous apprendrez ainsi à manipuler des objets géographiques en fonction d'attributs, tels que le nom des arrêts de bus, dans un jeux de données vectorielles et l'altitude des pixels dans un jeux de données raster.
Pour les données vectorielles, cela implique des techniques telles que le sous-ensemble et l'agrégation (voir les sections \@ref(vector-attribute-subsetting) et \@ref(vector-attribute-aggregation)).
Les sections \@ref(vector-attribute-joining) et \@ref(vec-attr-creation) montrent respectivement comment joindre des données à des objets *simple features* à l'aide d'un ID (identifiant) partagé et comment créer de nouvelles variables.
Chacune de ces opérations a un équivalent spatial :
L'opérateur `[` de la version de base de R, par exemple, fonctionne pour faire des sous-ensembles d'objets basé sur leur attribut que ces objets soient spatiaux ou non ; vous pouvez également joindre les attributs de deux jeux de données géographiques à l'aide de jointures spatiales.
C'est une bonne nouvelle : les compétences développées dans ce chapitre sont transférables.
Le chapitre \@ref(spatial-operations) étend les méthodes présentées ici au monde spatial.

Après une exploration en profondeur dans les différents types d'opérations sur les attributs *vectoriels*, les opérations sur les données attributaires *raster* sont abordées dans la section \@ref(manipulating-raster-objects). Elle montrera comment créer des couches raster contenant des attributs continus et catégoriels et comment extraire les valeurs des cellules d'une ou de plusieurs couches (sous-ensemble raster). 
La section \@ref(summarizing-raster-objects) fournit une vue d'ensemble des calculs matricielles "globaux" qui peuvent être utilisées pour résumer des jeux de données raster entiers.

## Manipulations des attributs de données vectorielles. 

Les jeux de données géographiques vectorielles sont bien supportés dans R grâce à la classe `sf`, qui étend la classe `data.frame` de R.
Comme les tableaux de données, les objets `sf` ont une colonne par variable attributaire (comme le 'nom') et une ligne par observation ou *élément* (par exemple, par station de bus).
Les objets `sf` diffèrent des cadres de données de base parce qu'ils ont une colonne `geometry` de la classe `sfc` qui peut contenir une gamme d'entités géographiques (points simples et 'multi', lignes et polygones) par ligne.
Ceci a été décrit dans le chapitre \@ref(spatial-class), qui a démontré comment les *méthodes génériques* telles que `plot()` et `summary()` fonctionnent avec les objets `sf`.
**sf** fournit également des méthodes génériques permettant aux objets `sf` de se comporter comme des tableaux de données ordinaires, comme le montre l'impression des méthodes de la classe :

```{r 03-attribute-operations-3, eval=FALSE}
methods(class = "sf") # liste des 12 premières méthodes possibles avec la class sf 
```

```{r 03-attribute-operations-4}
#>  [1] aggregate             cbind                 coerce               
#>  [4] initialize            merge                 plot                 
#>  [7] print                 rbind                 [                    
#> [10] [[<-                  $<-                   show                 
```

```{r 03-attribute-operations-5, eval=FALSE, echo=FALSE}
# Une autre manière de lister les méthodes associées à la classe sf:
attributes(methods(class = "sf"))$info %>% 
  dplyr::filter(!visible)
```

Beaucoup d'entre elles (`aggregate()`, `cbind()`, `merge()`, `rbind()` et `[`) servent à manipuler des tableaux de données.
`rbind()`, par exemple, lie deux tableaux de données, l'un "au-dessus" de l'autre.
`$<-` crée de nouvelles colonnes. 
Une caractéristique essentielle des objets `sf` est qu'ils stockent des données spatiales et non spatiales de la même manière, comme des colonnes dans un `data.frame`.

```{block2 03-attribute-operations-6, type = 'rmdnote'}
La colonne géométrique des objets `sf` est typiquement appelée `geometry` ou `geom` mais n´importe quel nom peut être utilisé.
La commande suivante, par exemple, crée une colonne géométrique nommée g :
  
`st_sf(data.frame(n = world$name_long), g = world$geom)`

Cela permet aux géométries importées des bases de données spatiales d´avoir une variété de noms tels que `wkb_geometry` et `the_geom`.
```

Les objets `sf` peuvent également étendre les classes `tidyverse` pour les tableaux de données, `tibble` et `tbl`.
\index{tidyverse (package)}.
Ainsi, **sf** permet d'utiliser toute la puissance des capacités d'analyse de données de R sur les données géographiques, que vous utilisiez les fonctions de base de R ou du tidyverse pour l'analyse des données.
\index{tibble}
(Voir [`Rdatatable/data.table#2273`](https://github.com/Rdatatable/data.table/issues/2273) pour une discussion sur la compatibilité entre les objets `sf` et le paquet `data.table` très rapide).
Avant d'utiliser ces capacités, il est utile de rappeler comment découvrir les propriétés de base des objets de données vectorielles.
Commençons par utiliser les fonctions de base de R pour découvrir l'ensemble de données `world` du paquet **spData**.

```{r 03-attribute-operations-7}
class(world) # c'est un objet sf et un (tidy) data.frame
dim(world)   # c'est un objet de deux dimensions avec 177 lignes et 11 colonnes
```

`world` contient dix colonnes non-géographiques (et une colonne de liste de géométrie) avec presque 200 lignes représentant les pays du monde.
La fonction `st_drop_geometry()` ne conserve que les données attributaires d'un objet `sf`, c'est-à-dire qu'elle supprime sa géométrie.

```{r 03-attribute-operations-8}
world_df = st_drop_geometry(world)
class(world_df)
ncol(world_df)
```

Il peut être utile de supprimer la colonne de géométrie avant de travailler avec des données attributaires ; les processus de manipulation des données peuvent s'exécuter plus rapidement lorsqu'ils ne travaillent que sur les attributs et les colonnes de géométrie ne sont pas toujours nécessaires.
Dans la plupart des cas, cependant, il est judicieux de conserver la colonne géométrique, ce qui explique pourquoi cette colonne est "collante" (elle reste après la plupart des opérations sur les attributs, sauf si elle est spécifiquement abandonnée).
Les opérations de données non spatiales sur les objets `sf` ne modifient la géométrie d'un objet que lorsque cela est approprié (par exemple, en supprimant les frontières entre les polygones adjacents après l'agrégation).
Devenir compétent dans la manipulation des données d'attributs géographiques signifie devenir compétent dans la manipulation des tableaux de données.

Pour de nombreuses applications, le paquet du tidyverse\index{tidyverse (package)} **dplyr** offre une approche efficace pour travailler avec des tableau de données.
La compatibilité avec le tidyverse est un avantage de **sf** par rapport à son prédécesseur **sp**, mais il y a quelques pièges à éviter (voir la vignette supplémentaire `tidyverse-pitfalls` à [geocompr.github.io](https://geocompr.github.io/geocompkg/articles/tidyverse-pitfalls.html) pour plus de détails).

### Sélection de sous ensemble dans des attributs de données vectorielles

Les méthodes de sélection de sous-ensembles de base de R incluent l'opérateur `[` et la fonction `subset()`.
Les principales fonctions de sélection de sous-ensembles **dplyr** sont `filter()` et `slice()` pour la sélection des lignes, et `select()` pour la sélection des colonnes.
Ces deux approches préservent les composantes spatiales des données attributaires dans les objets `sf`, tandis que l'utilisation de l'opérateur `$` ou de la fonction **dplyr** `pull()` pour retourner une seule colonne d'attribut sous forme de vecteur perdra les données d'attribut, comme nous le verrons plus loin.
\index{attribut!subsetting} 
Cette section se concentre sur la sélection de sous-ensemble de tableaux de données `sf` ; pour plus de détails sur les cas de vecteur et de tableaux de données non géographiques, nous vous recommandons de lire respectivement la section [2.7](https://cran.r-project.org/doc/manuals/r-release/R-intro.html#Index-vectors) de An Introduction to R [@rcoreteam_introduction_2021] et le chapitre [4](https://adv-r.hadley.nz/subsetting.html) de Advanced R Programming [@wickham_advanced_2019].

L'opérateur `[` peut sélectionner à la fois les lignes et les colonnes. 
Des chiffres d'index placés entre crochets directement après le nom d'un objet de type tableau de données spécifient les éléments à conserver.
La commande `object[i, j]` signifie 'retourner les lignes représentées par `i` et les colonnes représentées par `j`, où `i` et `j` contiennent typiquement des entiers ou des `TRUE`s et `FALSE`s (les index peuvent aussi être des chaînes de caractères, indiquant les noms de lignes ou de colonnes).
Par exemple, `objet[5, 1:3]` signifie 'retourner des données contenant la cinquième ligne et les colonnes 1 à 3 : le résultat devrait être un tableau de données avec seulement une ligne et trois colonnes, et une quatrième colonne de géométrie si c'est un objet `sf`.
Laisser `i` ou `j` vide retourne toutes les lignes ou colonnes, donc `world[1:5, ]` retourne les cinq premières lignes et les 11 colonnes.
Les exemples ci-dessous illustrent les sélections avec la base R.
Devinez le nombre de lignes et de colonnes dans les tableaux de données `sf` retournés par chaque commande et vérifiez les résultats sur votre propre ordinateur (cf. la fin du chapitre pour d'autres exercices) :

```{r 03-attribute-operations-9, eval=FALSE}
world[1:6, ]    # sélection de lignes par position
world[, 1:3]    # sélection de colonnes par position
world[1:6, 1:3] # sélection de lignes et  colonnes par position
world[, c("name_long", "pop")] # sélection de colonnes par leurs noms
world[, c(T, T, F, F, F, F, F, T, T, F, F)] # sélection en utilisant un vecteur logique
world[, 888] # un index référencent une colonne non-existente
```

```{r, eval=FALSE, echo=FALSE}
# ceux ci retourne un erreur
world[c(1, 5), c(T, T)]
world[c(1, 5), c(T, T, F, F, F, F, F, T, T, F, F, F)]
```

Une démonstration de l'utilité de l'utilisation de vecteurs `logiques` pour la sélection est démontrée dans le morceau de code ci-dessous.
Il crée un nouvel objet, `small_countries`, contenant les nations dont la surface est inférieure à 10,000 km^2^ :

```{r 03-attribute-operations-10}
i_small = world$area_km2 < 10000
summary(i_small) # on confirme le vecteur logique
small_countries = world[i_small, ]
```

L'objet intermédiaire `i_small` (abréviation de l'index représentant les petits pays) est un vecteur logique qui peut être utilisé pour sélectionner les sept plus petits pays du `monde` en fonction de leur superficie.
Une commande plus concise, qui omet l'objet intermédiaire, génère le même résultat :

```{r 03-attribute-operations-11}
small_countries = world[world$area_km2 < 10000, ]
```

La fonction de base de R `subset()` fournit un autre moyen d'obtenir le même résultat :

```{r 03-attribute-operations-12, eval=FALSE}
small_countries = subset(world, area_km2 < 10000)
```

Les fonctions de base de R sont matures, stables et largement utilisées, ce qui en fait un choix solide, en particulier dans les contextes où la reproductibilité et la fiabilité sont essentielles.
Les fonctions **dplyr** permettent des flux de travail "ordonnés" que certaines personnes (dont les auteurs de ce livre) trouvent intuitifs et productifs pour l'analyse interactive des données, en particulier lorsqu'elles sont associées à des éditeurs de code tels que RStudio qui permettent l'[auto-complétion](https://support.rstudio.com/hc/en-us/articles/205273297-Code-Completion-in-the-RStudio-IDE) des noms de colonnes.
Les fonctions clés pour les sélection dans les tableaux de données (y compris les tableaux de données `sf`) avec les fonctions **dplyr** sont démontrées ci-dessous.
<!-- The sentence below seems to be untrue based on the benchmark below. -->
<!-- `dplyr` is also faster than base R for some operations, due to its C++\index{C++} backend. -->
<!-- Something on dbplyr? I've never seen anyone use it regularly for spatial data 'in the wild' so leaving out the bit on integration with dbs for now (RL 2021-10) -->
<!-- The main **dplyr** subsetting functions are `select()`, `slice()`, `filter()` and `pull()`. -->

```{r, echo=FALSE, eval=FALSE}
# Aim: benchmark base vs dplyr subsetting
# Could move elsewhere? 
i = sample(nrow(world), size = 10)
benchmark_subset = bench::mark(
  world[i, ],
  world %>% slice(i)
)
benchmark_subset[c("expression", "itr/sec", "mem_alloc")]
# # October 2021 on laptop with CRAN version of dplyr:
# # A tibble: 2 × 3
#   expression         `itr/sec` mem_alloc
#   <bch:expr>             <dbl> <bch:byt>
# 1 world[i, ]             1744.    5.55KB
# 2 world %>% slice(i)      671.    4.45KB
```

`select()` sélectionne les colonnes par nom ou par leur position.
Par exemple, vous pouvez sélectionner seulement deux colonnes, `name_long` et `pop`, avec la commande suivante :

```{r 03-attribute-operations-14}
world1 = dplyr::select(world, name_long, pop)
names(world1)
```

Note : comme avec la commande équivalente de base de R (`world[, c("name_long", "pop")]`), la colonne collante `geom` reste.
`select()` permet également de sélectionner une plage de colonnes à l'aide de l'opérateur `:` :

```{r 03-attribute-operations-15}
# toutes les colonnes entre name_long et pop incluses
world2 = dplyr::select(world, name_long:pop)
```

Vous pouvez supprimer des colonnes spécifiques avec l'opérateur `-` :

```{r 03-attribute-operations-16}
# toutes les colonnes sauf subregion et area_km2 
world3 = dplyr::select(world, -subregion, -area_km2)
```

Sélectionner et renommer les colonnes en même temps avec la syntaxe `nouveau_nom = ancien_nom` :

```{r 03-attribute-operations-17}
world4 = dplyr::select(world, name_long, population = pop)
```

Il est intéressant de noter que la commande ci-dessus est plus concise que l'équivalent de base R, qui nécessite deux lignes de code :

```{r 03-attribute-operations-18, eval=FALSE}
world5 = world[, c("name_long", "pop")] # sélectionne les colonnes par nom
names(world5)[names(world5) == "pop"] = "population" # renommer les colonnes
```

`select()` fonctionne également avec des "fonctions d'aide" pour des opérations de sélections plus avancées, notamment `contains()`, `starts_with()` et `num_range()` (voir la page d'aide de `?select` pour plus de détails).

La plupart des verbes de **dplyr** retournent un tableau de données, mais vous pouvez extraire une seule colonne comme un vecteur avec `pull()`.
<!-- Note: I have commented out the statement below because it is not true for `sf` objects, it's a bit confusing that the behaviour differs between data frames and `sf` objects. -->
<!-- The subsetting operator in base R (see `?[`), by contrast, tries to return objects in the lowest possible dimension. -->
<!-- This means selecting a single column returns a vector in base R as demonstrated in code chunk below which returns a numeric vector representing the population of countries in the `world`: -->
Vous pouvez obtenir le même résultat grâce seulement avec la base de R avec les opérateurs de sélection de listes `$` et `[[`, les trois commandes suivantes retournent le même tableau numérique :

```{r 03-attribute-operations-21, eval = FALSE}
pull(world, pop)
world$pop
world[["pop"]]
```

<!-- Commenting out the following because it's confusing and covered better in other places (RL, 2021-10) -->
<!-- To turn off this behavior, set the `drop` argument to `FALSE`,  -->

```{r 03-attribute-operations-19, eval=FALSE, echo=FALSE}
# création d'un jeux de données test 
d = data.frame(pop = 1:10, area = 1:10)
# produit un tableau de donnée en sélectionnant une seule colonne
d[, "pop", drop = FALSE] # similaire à d["pop"]
select(d, pop)
# renvoie un vecteur en sélectionnant une seule colonne
d[, "pop"]
pull(d, pop)
```

```{r 03-attribute-operations-20, echo=FALSE, eval=FALSE}
x1 = d[, "pop", drop = FALSE] # equivalent to d["pop"]
x2 = d["pop"]
identical(x1, x2)
```

`slice()` est l'équivalent pour les lignes de `select()`.
Le morceau de code suivant, par exemple, sélectionne les lignes 1 à 6 :

```{r 03-attribute-operations-22, eval=FALSE}
slice(world, 1:6)
```

`filter()` est l'équivalent pour**dplyr** de la fonction `subset()` de R de base.
Elle ne conserve que les lignes correspondant à des critères donnés, par exemple, uniquement les pays dont la superficie est inférieure à un certain seuil, ou dont l'espérance de vie moyenne est élevée, comme le montrent les exemples suivants :

```{r 03-attribute-operations-23, eval=FALSE}
world7 = filter(world ,area_km2 < 10000) # les pays avec une petite surface
world7 = filter(world, lifeExp > 82)      # ceux avec une grande espérance de vie
```

L'ensemble des opérateurs de comparaison peut être utilisé dans la fonction `filter()`, comme illustré dans le tableau \@ref(tab:operators) : 

```{r operators0, echo=FALSE}
if (knitr::is_html_output()){
  operators = c("`==`", "`!=`", "`>`, `<`", "`>=`, `<=`", "`&`, <code>|</code>, `!`")
} else {
  operators = c("==", "!=", ">, <", ">=, <=", "&, |, !")
}
```

```{r operators, echo=FALSE}
operators_exp = c("Egal à", "Non égal à", "Supérieur/inférieur à",
                  "Supérieur/inférieur ou égal", 
                  "Opérateurs logiques : Et, Ou, Non")
knitr::kable(tibble(Symbole = operators, Nom = operators_exp), 
             caption = paste("Opérateurs de comparaison renvoyant des booléens",
                             "(TRUE/FALSE)."),
             caption.short = "Opérateurs de comparaison renvoyant des booléens.",
             booktabs = TRUE)
```

### Chaining commands with pipes

Key to workflows using **dplyr** functions is the ['pipe'](http://r4ds.had.co.nz/pipes.html) operator `%>%` (or since R `4.1.0` the native pipe `|>`), which takes its name from the Unix pipe `|` [@grolemund_r_2016].
Pipes enable expressive code: the output of a previous function becomes the first argument of the next function, enabling *chaining*.
This is illustrated below, in which only countries from Asia are filtered from the `world` dataset, next the object is subset by columns (`name_long` and `continent`) and the first five rows (result not shown).

```{r 03-attribute-operations-24}
world7 = world %>%
  filter(continent == "Asia") %>%
  dplyr::select(name_long, continent) %>%
  slice(1:5)
```

The above chunk shows how the pipe operator allows commands to be written in a clear order:
the above run from top to bottom (line-by-line) and left to right.
The alternative to `%>%` is nested function calls, which is harder to read:

```{r 03-attribute-operations-25}
world8 = slice(
  dplyr::select(
    filter(world, continent == "Asia"),
    name_long, continent),
  1:5)
```

### Vector attribute aggregation

\index{attribute!aggregation}
\index{aggregation}
Aggregation involves summarizing data with one or more 'grouping variables', typically from columns in the data frame to be aggregated (geographic aggregation is covered in the next chapter).
An example of attribute aggregation is calculating the number of people per continent based on country-level data (one row per country).
The `world` dataset contains the necessary ingredients: the columns `pop` and `continent`, the population and the grouping variable, respectively.
The aim is to find the `sum()` of country populations for each continent, resulting in a smaller data frame (aggregation is a form of data reduction and can be a useful early step when working with large datasets).
This can be done with the base R function `aggregate()` as follows:

```{r 03-attribute-operations-26}
world_agg1 = aggregate(pop ~ continent, FUN = sum, data = world,
                       na.rm = TRUE)
class(world_agg1)
```

The result is a non-spatial data frame with six rows, one per continent, and two columns reporting the name and population of each continent (see Table \@ref(tab:continents) with results for the top 3 most populous continents).

`aggregate()` is a [generic function](https://adv-r.hadley.nz/s3.html#s3-methods) which means that it behaves differently depending on its inputs. 
**sf** provides the method `aggregate.sf()` which is activated automatically when `x` is an `sf` object and a `by` argument is provided:

```{r 03-attribute-operations-27}
world_agg2 = aggregate(world["pop"], list(world$continent), FUN = sum, 
                       na.rm = TRUE)
class(world_agg2)
nrow(world_agg2)
```

The resulting `world_agg2` object is a spatial object containing 8 features representing the continents of the world (and the open ocean).
`group_by() %>% summarize()` is the **dplyr** equivalent of `aggregate()`, with the variable name provided in the `group_by()` function specifying the grouping variable and information on what is to be summarized passed to the `summarize()` function, as shown below:

```{r 03-attribute-operations-28}
world_agg3 = world %>%
  group_by(continent) %>%
  summarize(pop = sum(pop, na.rm = TRUE))
```

The approach may seem more complex but it has benefits: flexibility, readability, and control over the new column names.
This flexibility is illustrated in the command below, which calculates not only the population but also the area and number of countries in each continent:

```{r 03-attribute-operations-29}
world_agg4  = world %>% 
  group_by(continent) %>%
  summarize(pop = sum(pop, na.rm = TRUE), `area (sqkm)` = sum(area_km2), n = n())
```

In the previous code chunk `pop`, `area (sqkm)` and `n` are column names in the result, and `sum()` and `n()` were the aggregating functions.
These aggregating functions return `sf` objects with rows representing continents and geometries containing the multiple polygons representing each land mass and associated islands (this works thanks to the geometric operation 'union', as explained in Section \@ref(geometry-unions)).

Let's combine what we have learned so far about **dplyr** functions, by chaining multiple commands to summarize attribute data about countries worldwide by continent.
The following command calculates population density (with `mutate()`), arranges continents by the number countries they contain (with `dplyr::arrange()`), and keeps only the 3 most populous continents (with `top_n()`), the result of which is presented in Table \@ref(tab:continents)):

```{r 03-attribute-operations-30}
world_agg5 = world %>% 
  st_drop_geometry() %>%                      # drop the geometry for speed
  dplyr::select(pop, continent, area_km2) %>% # subset the columns of interest  
  group_by(continent) %>%                     # group by continent and summarize:
  summarize(Pop = sum(pop, na.rm = TRUE), Area = sum(area_km2), N = n()) %>%
  mutate(Density = round(Pop / Area)) %>%     # calculate population density
  top_n(n = 3, wt = Pop) %>%                  # keep only the top 3
  arrange(desc(N))                            # arrange in order of n. countries
```

```{r continents, echo=FALSE}
options(scipen = 999)
knitr::kable(
  world_agg5,
  caption = "The top 3 most populous continents ordered by population density (people per square km).",
  caption.short = "Top 3 most populous continents.",
  booktabs = TRUE
)
```

```{block2 03-attribute-operations-31, type='rmdnote'}
More details are provided in the help pages (which can be accessed via `?summarize` and `vignette(package = "dplyr")` and Chapter 5 of [R for Data Science](http://r4ds.had.co.nz/transform.html#grouped-summaries-with-summarize). 
```

###  Vector attribute joining

Combining data from different sources is a common task in data preparation. 
Joins do this by combining tables based on a shared 'key' variable.
**dplyr** has multiple join functions including `left_join()` and `inner_join()` --- see `vignette("two-table")` for a full list.
These function names follow conventions used in the database language [SQL](http://r4ds.had.co.nz/relational-data.html) [@grolemund_r_2016, Chapter 13]; using them to join non-spatial datasets to `sf` objects is the focus of this section.
**dplyr** join functions work the same on data frames and `sf` objects, the only important difference being the `geometry` list column.
The result of data joins can be either an `sf` or `data.frame` object.
The most common type of attribute join on spatial data takes an `sf` object as the first argument and adds columns to it from a `data.frame` specified as the second argument.
\index{join}
\index{attribute!join}

To demonstrate joins, we will combine data on coffee production with the `world` dataset.
The coffee data is in a data frame called `coffee_data` from the **spData** package (see `?coffee_data` for details).
It has 3 columns:
`name_long` names major coffee-producing nations and `coffee_production_2016` and `coffee_production_2017` contain estimated values for coffee production in units of 60-kg bags in each year.
A 'left join', which preserves the first dataset, merges `world` with `coffee_data`:

```{r 03-attribute-operations-32, warning=FALSE}
world_coffee = left_join(world, coffee_data)
class(world_coffee)
```

Because the input datasets share a 'key variable' (`name_long`) the join worked without using the `by` argument (see `?left_join` for details).
The result is an `sf` object identical to the original `world` object but with two new variables (with column indices 11 and 12) on coffee production.
This can be plotted as a map, as illustrated in Figure \@ref(fig:coffeemap), generated with the `plot()` function below:

```{r coffeemap, fig.cap="World coffee production (thousand 60-kg bags) by country, 2017. Source: International Coffee Organization.", fig.scap="World coffee production by country."}
names(world_coffee)
plot(world_coffee["coffee_production_2017"])
```

For joining to work, a 'key variable' must be supplied in both datasets.
By default **dplyr** uses all variables with matching names.
In this case, both `world_coffee` and `world` objects contained a variable called `name_long`, explaining the message `Joining, by = "name_long"`.
In the majority of cases where variable names are not the same, you have two options:

1. Rename the key variable in one of the objects so they match.
2. Use the `by` argument to specify the joining variables.

The latter approach is demonstrated below on a renamed version of `coffee_data`:

```{r 03-attribute-operations-33, warning=FALSE}
coffee_renamed = rename(coffee_data, nm = name_long)
world_coffee2 = left_join(world, coffee_renamed, by = c(name_long = "nm"))
```

```{r 03-attribute-operations-34, eval=FALSE, echo=FALSE}
identical(world_coffee, world_coffee2)
nrow(world)
nrow(world_coffee)
```

Note that the name in the original object is kept, meaning that `world_coffee` and the new object `world_coffee2` are identical.
Another feature of the result is that it has the same number of rows as the original dataset.
Although there are only 47 rows of data in `coffee_data`, all 177 country records are kept intact in `world_coffee` and `world_coffee2`:
rows in the original dataset with no match are assigned `NA` values for the new coffee production variables.
What if we only want to keep countries that have a match in the key variable?
In that case an inner join can be used:

```{r 03-attribute-operations-35, warning=FALSE}
world_coffee_inner = inner_join(world, coffee_data)
nrow(world_coffee_inner)
```

Note that the result of `inner_join()` has only 45 rows compared with 47 in `coffee_data`.
What happened to the remaining rows?
We can identify the rows that did not match using the `setdiff()` function as follows:

```{r 03-attribute-operations-36}
setdiff(coffee_data$name_long, world$name_long)
```

The result shows that `Others` accounts for one row not present in the `world` dataset and that the name of the `Democratic Republic of the Congo` accounts for the other:
it has been abbreviated, causing the join to miss it.
The following command uses a string matching (regex) function from the **stringr** package to confirm what `Congo, Dem. Rep. of` should be:

```{r 03-attribute-operations-37}
(drc = stringr::str_subset(world$name_long, "Dem*.+Congo"))
```

```{r, echo=FALSE, eval=FALSE}
world$name_long[grepl(pattern = "Dem*.+Congo", world$name_long)] # base R
```

```{r 03-attribute-operations-38, eval=FALSE, echo=FALSE}
# aim: test names in coffee_data and world objects
str_subset(coffee_data$name_long, "Ivo|Congo,")
.Last.value %in% str_subset(world$name_long, "Ivo|Dem*.+Congo")
```

To fix this issue, we will create a new version of `coffee_data` and update the name.
`inner_join()`ing the updated data frame returns a result with all 46 coffee-producing nations:

```{r 03-attribute-operations-39, warning=FALSE}
coffee_data$name_long[grepl("Congo,", coffee_data$name_long)] = drc
world_coffee_match = inner_join(world, coffee_data)
nrow(world_coffee_match)
```

It is also possible to join in the other direction: starting with a non-spatial dataset and adding variables from a simple features object.
This is demonstrated below, which starts with the `coffee_data` object and adds variables from the original `world` dataset.
In contrast with the previous joins, the result is *not* another simple feature object, but a data frame in the form of a **tidyverse** tibble:
the output of a join tends to match its first argument:

```{r 03-attribute-operations-40, warning=FALSE}
coffee_world = left_join(coffee_data, world)
class(coffee_world)
```

```{block2 03-attribute-operations-41, type='rmdnote'}
In most cases, the geometry column is only useful in an `sf` object.
The geometry column can only be used for creating maps and spatial operations if R 'knows' it is a spatial object, defined by a spatial package such as **sf**.
Fortunately, non-spatial data frames with a geometry list column (like `coffee_world`) can be coerced into an `sf` object as follows: `st_as_sf(coffee_world)`. 
```

This section covers the majority of joining use cases.
For more information, we recommend @grolemund_r_2016, the [join vignette](https://geocompr.github.io/geocompkg/articles/join.html) in the **geocompkg** package that accompanies this book, and documentation of the **data.table** package.^[
**data.table** is a high-performance data processing package.
Its application to geographic data is covered in a blog post hosted at r-spatial.org/r/2017/11/13/perp-performance.html.
]
Another type of join is a spatial join, covered in the next chapter (Section \@ref(spatial-joining)).

### Creating attributes and removing spatial information {#vec-attr-creation}

Often, we would like to create a new column based on already existing columns.
For example, we want to calculate population density for each country.
For this we need to divide a population column, here `pop`, by an area column, here `area_km2` with unit area in square kilometers.
Using base R, we can type:

```{r 03-attribute-operations-42}
world_new = world # do not overwrite our original data
world_new$pop_dens = world_new$pop / world_new$area_km2
```

Alternatively, we can use one of **dplyr** functions - `mutate()` or `transmute()`.
`mutate()` adds new columns at the penultimate position in the `sf` object (the last one is reserved for the geometry):

```{r 03-attribute-operations-43, eval=FALSE}
world %>% 
  mutate(pop_dens = pop / area_km2)
```

The difference between `mutate()` and `transmute()` is that the latter drops all other existing columns (except for the sticky geometry column):

```{r 03-attribute-operations-44, eval=FALSE}
world %>% 
  transmute(pop_dens = pop / area_km2)
```

`unite()` from the **tidyr** package (which provides many useful functions for reshaping datasets, including `pivot_longer()`) pastes together existing columns.
For example, we want to combine the `continent` and `region_un` columns into a new column named `con_reg`.
Additionally, we can define a separator (here: a colon `:`) which defines how the values of the input columns should be joined, and if the original columns should be removed (here: `TRUE`):

```{r 03-attribute-operations-45, eval=FALSE}
world_unite = world %>%
  unite("con_reg", continent:region_un, sep = ":", remove = TRUE)
```

The `separate()` function does the opposite of `unite()`: it splits one column into multiple columns using either a regular expression or character positions.
This function also comes from the **tidyr** package.

```{r 03-attribute-operations-46, eval=FALSE}
world_separate = world_unite %>% 
  separate(con_reg, c("continent", "region_un"), sep = ":")
```

```{r 03-attribute-operations-47, echo=FALSE, eval=FALSE}
identical(world, world_separate)
```

The **dplyr** function `rename()` and the base R function `setNames()` are useful for renaming columns.
The first replaces an old name with a new one.
The following command, for example, renames the lengthy `name_long` column to simply `name`:

```{r 03-attribute-operations-48, eval=FALSE}
world %>% 
  rename(name = name_long)
```

`setNames()` changes all column names at once, and requires a character vector with a name matching each column.
This is illustrated below, which outputs the same `world` object, but with very short names: 

```{r 03-attribute-operations-49, eval=FALSE, echo=FALSE}
abbreviate(names(world), minlength = 1) %>% dput()
```

```{r 03-attribute-operations-50, eval=FALSE}
new_names = c("i", "n", "c", "r", "s", "t", "a", "p", "l", "gP", "geom")
world %>% 
  setNames(new_names)
```

It is important to note that attribute data operations preserve the geometry of the simple features.
As mentioned at the outset of the chapter, it can be useful to remove the geometry.
To do this, you have to explicitly remove it.
Hence, an approach such as `select(world, -geom)` will be unsuccessful and you should instead use `st_drop_geometry()`.^[
`st_geometry(world_st) = NULL` also works to remove the geometry from `world`, but overwrites the original object.
]

```{r 03-attribute-operations-51}
world_data = world %>% st_drop_geometry()
class(world_data)
```

## Manipulating raster objects
<!--jn-->

In contrast to the vector data model underlying simple features (which represents points, lines and polygons as discrete entities in space), raster data represent continuous surfaces.
This section shows how raster objects work by creating them *from scratch*, building on Section \@ref(an-introduction-to-terra).
Because of their unique structure, subsetting and other operations on raster datasets work in a different way, as demonstrated in Section \@ref(raster-subsetting).
\index{raster!manipulation}

The following code recreates the raster dataset used in Section \@ref(raster-classes), the result of which is illustrated in Figure \@ref(fig:cont-raster).
This demonstrates how the `rast()` function works to create an example raster named `elev` (representing elevations).

```{r 03-attribute-operations-52, message=FALSE, eval = FALSE}
elev = rast(nrows = 6, ncols = 6, resolution = 0.5, 
            xmin = -1.5, xmax = 1.5, ymin = -1.5, ymax = 1.5,
            vals = 1:36)
```

The result is a raster object with 6 rows and 6 columns (specified by the `nrow` and `ncol` arguments), and a minimum and maximum spatial extent in x and y direction (`xmin`, `xmax`, `ymin`, `ymax`).
The `vals` argument sets the values that each cell contains: numeric data ranging from 1 to 36 in this case.
Raster objects can also contain categorical values of class `logical` or `factor` variables in R.
The following code creates the raster datasets shown in Figure \@ref(fig:cont-raster):

```{r 03-attribute-operations-53, eval = FALSE}
grain_order = c("clay", "silt", "sand")
grain_char = sample(grain_order, 36, replace = TRUE)
grain_fact = factor(grain_char, levels = grain_order)
grain = rast(nrows = 6, ncols = 6, resolution = 0.5, 
             xmin = -1.5, xmax = 1.5, ymin = -1.5, ymax = 1.5,
             vals = grain_fact)
```

```{r 03-attribute-operations-54, include = FALSE}
elev = rast(system.file("raster/elev.tif", package = "spData"))
grain = rast(system.file("raster/grain.tif", package = "spData"))
```

The raster object stores the corresponding look-up table or "Raster Attribute Table" (RAT) as a list of data frames, which can be viewed with `cats(grain)` (see `?cats()` for more information).
Each element of this list is a layer of the raster.
It is also possible to use the function `levels()` for retrieving and adding new or replacing existing factor levels:

```{r 03-attribute-operations-56}
levels(grain)[[1]] = c(levels(grain)[[1]], wetness = c("wet", "moist", "dry"))
levels(grain)
```

```{r cont-raster, echo = FALSE, message = FALSE, fig.asp=0.5, fig.cap = "Raster datasets with numeric (left) and categorical values (right).", fig.scap="Raster datasets with numeric and categorical values.", warning=FALSE}
# knitr::include_graphics("https://user-images.githubusercontent.com/1825120/146617366-7308535b-30f6-4c87-83f7-21702c7d993b.png")
source("https://github.com/Robinlovelace/geocompr/raw/main/code/03-cont-raster-plot.R", print.eval = TRUE)
```

```{block2 coltab, type='rmdnote'}
Categorical raster objects can also store information about the colors associated with each value using a color table.
The color table is a data frame with three (red, green, blue) or four (alpha) columns, where each row relates to one value.
Color tables in **terra** can be viewed or set with the `coltab()` function (see `?coltab`).
Importantly, saving a raster object with a color table to a file (e.g., GeoTIFF) will also save the color information.
```

### Raster subsetting

Raster subsetting is done with the base R operator `[`, which accepts a variety of inputs:
\index{raster!subsetting}

- Row-column indexing
- Cell IDs
- Coordinates (see Section \@ref(spatial-raster-subsetting))
- Another spatial object (see Section \@ref(spatial-raster-subsetting))

Here, we only show the first two options since these can be considered non-spatial operations.
If we need a spatial object to subset another or the output is a spatial object, we refer to this as spatial subsetting.
Therefore, the latter two options will be shown in the next chapter (see Section \@ref(spatial-raster-subsetting)).

The first two subsetting options are demonstrated in the commands below ---
both return the value of the top left pixel in the raster object `elev` (results not shown):

```{r 03-attribute-operations-58, eval = FALSE}
# row 1, column 1
elev[1, 1]
# cell ID 1
elev[1]
```

Subsetting of multi-layered raster objects will return the cell value(s) for each layer.
For example, `c(elev, grain)[1]` returns a data frame with one row and two columns --- one for each layer.
To extract all values or complete rows, you can also use `values()`.

Cell values can be modified by overwriting existing values in conjunction with a subsetting operation.
The following code chunk, for example, sets the upper left cell of `elev` to 0 (results not shown):

```{r 03-attribute-operations-60, results='hide'}
elev[1, 1] = 0
elev[]
```

Leaving the square brackets empty is a shortcut version of `values()` for retrieving all values of a raster.
Multiple cells can also be modified in this way:

```{r 03-attribute-operations-61}
elev[1, c(1, 2)] = 0
```

Replacing values of multilayered rasters can be done with a matrix with as many columns as layers and rows as replaceable cells (results not shown):

```{r 03-attribute-operations-61b, eval=FALSE}
two_layers = c(grain, elev) 
two_layers[1] = cbind(c(0), c(4))
two_layers[]
```

### Summarizing raster objects

**terra** contains functions for extracting descriptive statistics\index{statistics} for entire rasters.
Printing a raster object to the console by typing its name returns minimum and maximum values of a raster.
`summary()` provides common descriptive statistics\index{statistics} -- minimum, maximum, quartiles and number of `NA`s for continuous rasters and a number of cells of each class for categorical rasters.
Further summary operations such as the standard deviation (see below) or custom summary statistics can be calculated with `global()`. 
\index{raster!summarizing}

```{r 03-attribute-operations-62, eval = FALSE}
global(elev, sd)
```

```{block2 03-attribute-operations-63, type='rmdnote'}
If you provide the `summary()` and `global()` functions with a multi-layered raster object, they will summarize each layer separately, as can be illustrated by running: `summary(c(elev, grain))`.
```

Additionally, the `freq()` function allows to get the frequency table of categorical values.

Raster value statistics can be visualized in a variety of ways.
Specific functions such as `boxplot()`, `density()`, `hist()` and `pairs()` work also with raster objects, as demonstrated in the histogram created with the command below (not shown):

```{r 03-attribute-operations-64, eval=FALSE}
hist(elev)
```

In case the desired visualization function does not work with raster objects, one can extract the raster data to be plotted with the help of `values()` (Section \@ref(raster-subsetting)).
\index{raster!values}

Descriptive raster statistics belong to the so-called global raster operations.
These and other typical raster processing operations are part of the map algebra scheme, which are covered in the next chapter (Section \@ref(map-algebra)).

```{block 03-attribute-operations-65, type='rmdnote'}
Some function names clash between packages (e.g., a function with the name `extract()` exist in both **terra** and **tidyr** packages).
In addition to not loading packages by referring to functions verbosely (e.g., `tidyr::extract()`), another way to prevent function names clashes is by unloading the offending package with `detach()`.
The following command, for example, unloads the **terra** package (this can also be done in the *package* tab which resides by default in the right-bottom pane in RStudio): `detach("package:terra", unload = TRUE, force = TRUE)`.
The `force` argument makes sure that the package will be detached even if other packages depend on it.
This, however, may lead to a restricted usability of packages depending on the detached package, and is therefore not recommended.
```

## Exercises

```{r, echo=FALSE, results='asis'}
res = knitr::knit_child('_03-ex.Rmd', quiet = TRUE, options = list(include = FALSE, eval = FALSE))
cat(res, sep = '\n')
```
